{"version":3,"sources":["webpack:///./src/components/modals/ExpressionModal.vue?ca0b","webpack:///./src/components/modals/ExpressionModal.vue?6ff1","webpack:///src/components/modals/ExpressionModal.vue","webpack:///./src/components/modals/ExpressionModal.vue?41bd","webpack:///./src/components/modals/ExpressionModal.vue"],"names":["render","_vm","this","_h","$createElement","_c","_self","ref","attrs","scopedSlots","_u","key","fn","staticClass","on","$event","onDrop","allowDrop","model","value","callback","$$v","input","expression","_v","_l","op","title","emit","processId","onDrag","_s","mathProcesses","func","id","summary","results","pgParameters","param","spec","schema","_e","proxy","createResult","staticRenderFns","component"],"mappings":"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SAASvB,EAAIuB,GAAG,yBAAyBnB,EAAG,MAAM,CAACJ,EAAIuB,GAAG,QAAQvB,EAAIuB,GAAG,4EAA4EvB,EAAIwC,QAAQ,KAAKC,OAAM,GAAM,CAAC/B,IAAI,SAASC,GAAG,WAAW,MAAO,CAACP,EAAG,MAAM,CAACQ,YAAY,UAAU,CAACR,EAAG,SAAS,CAACG,MAAM,CAAC,KAAO,UAAUM,GAAG,CAAC,MAAQb,EAAI0C,eAAe,CAAC1C,EAAIuB,GAAG,gBAAgBkB,OAAM,QAC1nGE,EAAkB,G,oFCgDtB,GACA,uBACA,gBACA,YACA,aACA,mBAEA,OACA,OACA,SACA,gBACA,iBACA,gBACA,UACA,aAGA,aACA,+EACA,0CACA,8FACA,YACA,SACA,mCACA,8BACA,sCACA,mCAEA,UAEA,UACA,SACA,gCACA,2BACA,yCACA,yBACA,UAGA,UAEA,uBAEA,gCACA,SAIA,gDACA,YASA,SACA,gBACA,wCACA,eACA,cACA,gBACA,oBACA,0FAEA,IACA,sBACA,SACA,gBAIA,GADA,uBACA,aAEA,gCACA,2BACA,kFACA,0DAKA,cACA,UACA,gBACA,wCACA,4BACA,MACA,cACA,QACA,MAEA,wCAEA,aACA,oBAEA,UACA,2CACA,IACA,mBACA,iCAGA,iBACA,0BACA,OAGA,oDACA,UACA,4CACA,IACA,aACA,kBAGA,wBACA,kCACA,2DAGA,gDACA,yCACA,+DAEA,MACA,sBACA,gBACA,+CAEA,EADA,EACA,wBAGA,oBAGA,sBAIA,uCAHA,mBAMA,UAIA,KACA,8CACA,gBACA,kCAEA,yCACA,iBACA,MAEA,0BACA,cAEA,mCAIA,+DAHA,mBAYA,GAJA,IACA,yBAGA,GACA,gBACA,YACA,IACA,wBACA,QAGA,OACA,GACA,8BACA,8BACA,SACA,6BAEA,EAGA,UAIA,0CAGA,eACA,yBAKA,IACA,eACA,mCACA,yBACA,qCACA,8CAGA,mCAEA,4CACA,yBACA,SACA,8BAjBA,0BAoBA,aACA,wBACA,UACA,aACA,mCACA,iBACA,iCACA,iBACA,oCACA,mBACA,SACA,iCACA,+CAEA,8CACA,aACA,+BACA,kBACA,8BACA,gCAEA,YACA,yCACA,6BACA,qBACA,EAGA,kCAIA,EAEA,QACA,oDAGA,UAEA,cACA,SAEA,eACA,SAEA,cACA,YAIA,2CACA,qBACA,4BACA,oBAIA,sEACA,qBACA,+BAEA,OACA,MACA,yCAGA,iBACA,8BAGA,UAEA,yDAEA,6BAOA,OAHA,6CAGA,oBAEA,0BACA,iDACA,wDACA,KACA,2DACA,gFAIA,OAFA,+BACA,+BACA,qBAGA,kDAGA,gBAKA,GAJA,sBACA,gCAGA,EACA,gDAEA,sCACA,0GAIA,qBACA,SACA,gBACA,sBACA,eAEA,IAKA,2BACA,GACA,gBACA,aAGA,OADA,iBACA,iBChZwW,I,wBCQpWC,EAAY,eACd,EACA7C,EACA4C,GACA,EACA,KACA,WACA,MAIa,aAAAC,E","file":"js/chunk-65c369a9.c532b5cd.js","sourcesContent":["export * from \"-!../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../../node_modules/css-loader/dist/cjs.js??ref--6-oneOf-1-1!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ExpressionModal.vue?vue&type=style&index=0&id=396a9ae3&scoped=true&lang=css&\"","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Modal',{ref:\"modal\",attrs:{\"minWidth\":\"70%\"},scopedSlots:_vm._u([{key:\"main\",fn:function(){return [_c('div',{staticClass:\"content\"},[_c('TextEditor',{ref:\"editor\",staticClass:\"editor\",attrs:{\"id\":\"input\",\"language\":\"math\",\"placeholder\":\"e.g. x * 2.5 / (x - y)\"},on:{\"drop\":function($event){return _vm.onDrop($event)},\"dragover\":function($event){return _vm.allowDrop($event)}},model:{value:(_vm.input),callback:function ($$v) {_vm.input=$$v},expression:\"input\"}}),_c('div',{staticClass:\"description\"},[_c('p',[_c('i',{staticClass:\"fas fa-info-circle\"}),_vm._v(\" Above you can insert a mathematical formula and it will be converted to openEO code for you.\")]),_c('p',[_c('strong',[_vm._v(\"Operators\")]),_vm._v(\":\"),_c('br'),_vm._l((_vm.operators),function(op){return _c('kbd',{key:op.op,staticClass:\"click\",attrs:{\"title\":op.title,\"draggable\":\"true\"},on:{\"click\":function($event){return _vm.emit('showProcess', op.processId)},\"dragstart\":function($event){return _vm.onDrag($event, 'operators', op.op)}}},[_vm._v(_vm._s(op.op))])})],2),_c('p',[_vm._v(\"Supported \"),_c('strong',[_vm._v(\"mathematical functions\")]),_vm._v(\": \"),(_vm.mathProcesses.length)?[_c('br'),_vm._l((_vm.mathProcesses),function(func){return _c('kbd',{key:func.id,staticClass:\"click\",attrs:{\"title\":func.summary,\"draggable\":\"true\"},on:{\"click\":function($event){return _vm.emit('showProcess', func.id)},\"dragstart\":function($event){return _vm.onDrag($event, 'functions', func)}}},[_vm._v(_vm._s(func.id))])})]:[_vm._v(\"None\")]],2),_c('p',[_vm._v(\"Available \"),_c('strong',[_vm._v(\"output from processes\")]),_vm._v(\": \"),(_vm.results.length)?[_c('br'),_vm._l((_vm.results),function(id){return _c('kbd',{key:id,attrs:{\"draggable\":\"true\"},on:{\"dragstart\":function($event){return _vm.onDrag($event, 'results', id)}}},[_vm._v(\"#\"+_vm._s(id))])})]:[_vm._v(\"None\")]],2),_c('p',[_c('strong',[_vm._v(\"Parameters\")]),_vm._v(\": If a variable is found in the formula which can't be resolved to a pre-defined parameter, a new parameter will be created for it. Available pre-defined parameters: \"),(_vm.pgParameters.length)?[_c('br'),_vm._l((_vm.pgParameters),function(param){return _c('kbd',{key:param.id,staticClass:\"click\",attrs:{\"draggable\":\"true\"},on:{\"click\":function($event){return _vm.emit('showSchema', param.id, param.spec.schema)},\"dragstart\":function($event){return _vm.onDrag($event, 'pgParameters', param.id)}}},[_vm._v(_vm._s(param.id))])})]:[_vm._v(\"None\")]],2),(_vm.supportsArrayElement)?_c('p',[_vm._v(\"If the first pre-defined parameter is a (labeled) \"),_c('strong',[_vm._v(\"array\")]),_vm._v(\", the value for a specific index or label can be accessed by typing the numeric index or textual label with a \"),_c('kbd',[_vm._v(\"$\")]),_vm._v(\" in front, for example \"),_c('kbd',[_vm._v(\"$B1\")]),_vm._v(\" for the label B1 or \"),_c('kbd',[_vm._v(\"$0\")]),_vm._v(\" for the first element in the array. Numeric labels are not supported.\")]):_vm._e()])],1)]},proxy:true},{key:\"footer\",fn:function(){return [_c('div',{staticClass:\"footer\"},[_c('button',{attrs:{\"type\":\"button\"},on:{\"click\":_vm.createResult}},[_vm._v(\"Insert\")])])]},proxy:true}])})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n\t<Modal ref=\"modal\" minWidth=\"70%\">\n\t\t<template #main>\n\t\t\t<div class=\"content\">\n\t\t\t\t<TextEditor ref=\"editor\" id=\"input\" class=\"editor\" v-model=\"input\" language=\"math\" placeholder=\"e.g. x * 2.5 / (x - y)\" @drop=\"onDrop($event)\" @dragover=\"allowDrop($event)\" />\n\t\t\t\t<div class=\"description\">\n\t\t\t\t\t<p><i  class=\"fas fa-info-circle\"></i> Above you can insert a mathematical formula and it will be converted to openEO code for you.</p>\n\t\t\t\t\t<p><strong>Operators</strong>:<br />\n\t\t\t\t\t\t<kbd v-for=\"op in operators\" :key=\"op.op\" :title=\"op.title\" @click=\"emit('showProcess', op.processId)\" class=\"click\" draggable=\"true\" @dragstart=\"onDrag($event, 'operators', op.op)\">{{ op.op }}</kbd>\n\t\t\t\t\t</p>\n\t\t\t\t\t<p>Supported <strong>mathematical functions</strong>:\n\t\t\t\t\t\t<template v-if=\"mathProcesses.length\">\n\t\t\t\t\t\t\t<br /><kbd v-for=\"func in mathProcesses\" :key=\"func.id\" :title=\"func.summary\" @click=\"emit('showProcess', func.id)\" class=\"click\" draggable=\"true\" @dragstart=\"onDrag($event, 'functions', func)\">{{ func.id }}</kbd>\n\t\t\t\t\t\t</template>\n\t\t\t\t\t\t<template v-else>None</template>\n\t\t\t\t\t</p>\n\t\t\t\t\t<p>Available <strong>output from processes</strong>:\n\t\t\t\t\t\t<template v-if=\"results.length\">\n\t\t\t\t\t\t\t<br /><kbd v-for=\"id in results\" :key=\"id\" draggable=\"true\" @dragstart=\"onDrag($event, 'results', id)\">#{{ id }}</kbd> <!-- ToDo: Open non-editable parameter editor or process schema -->\n\t\t\t\t\t\t</template>\n\t\t\t\t\t\t<template v-else>None</template>\n\t\t\t\t\t</p>\n\t\t\t\t\t<p><strong>Parameters</strong>: If a variable is found in the formula which can't be resolved to a pre-defined parameter, a new parameter will be created for it. Available pre-defined parameters:\n\t\t\t\t\t\t<template v-if=\"pgParameters.length\">\n\t\t\t\t\t\t\t<br /><kbd v-for=\"param in pgParameters\" :key=\"param.id\" @click=\"emit('showSchema', param.id, param.spec.schema)\" class=\"click\" draggable=\"true\" @dragstart=\"onDrag($event, 'pgParameters', param.id)\">{{ param.id }}</kbd>\n\t\t\t\t\t\t</template>\n\t\t\t\t\t\t<template v-else>None</template>\n\t\t\t\t\t</p>\n\t\t\t\t\t<p v-if=\"supportsArrayElement\">If the first pre-defined parameter is a (labeled) <strong>array</strong>, the value for a specific index or label can be accessed by typing the numeric index or textual label with a <kbd>$</kbd> in front, for example <kbd>$B1</kbd> for the label B1 or <kbd>$0</kbd> for the first element in the array. Numeric labels are not supported.</p>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</template>\n\t\t<template #footer>\n\t\t\t<div class=\"footer\">\n\t\t\t\t<button type=\"button\" @click=\"createResult\">Insert</button>\n\t\t\t</div>\n\t\t</template>\n\t</Modal>\n</template>\n\n<script>\nimport Modal from './Modal.vue';\nimport Utils from '../../utils.js';\nimport TextEditor from '../TextEditor.vue';\nimport EventBusMixin from '../EventBusMixin.vue';\nimport { Process } from '../blocks/processSchema.js';\nimport { ProcessGraph } from '@openeo/js-processgraphs';\nimport { Formula } from '@openeo/js-client';\n\nexport default {\n\tname: 'ExpressionModal',\n\tmixins: [EventBusMixin],\n\tcomponents: {\n\t\tModal,\n\t\tTextEditor\n\t},\n\tdata() {\n\t\treturn {\n\t\t\tinput: '',\n\t\t\tpgParameters: [],\n\t\t\tarrayElements: {},\n\t\t\tprocessGraph: {},\n\t\t\tresult: {},\n\t\t\treplace: false\n\t\t};\n\t},\n\tcomputed: {\n\t\t...Utils.mapState('userProcesses', ['operatorMapping', 'arrayOperatorMapping']),\n\t\t...Utils.mapGetters(['processRegistry']),\n\t\t...Utils.mapGetters('userProcesses', ['mathProcesses', 'isMathProcess', 'reverseOperatorMapping']),\n\t\toperators() {\n\t\t\tvar ops = [];\n\t\t\tfor(var op in this.operatorMapping) {\n\t\t\t\tlet processId = this.operatorMapping[op];\n\t\t\t\tlet title = this.processRegistry.get(processId).summary;\n\t\t\t\tops.push({op, processId, title});\n\t\t\t}\n\t\t\treturn ops;\n\t\t},\n\t\tresults() {\n\t\t\tlet resultNodes = [];\n\t\t\tfor(var id in this.processGraph) {\n\t\t\t\tvar node = this.processGraph[id];\n\t\t\t\tvar p = this.processRegistry.get(node.process_id);\n\t\t\t\tif (Process.isMathProcess(p)) {\n\t\t\t\t\tresultNodes.push(id);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn resultNodes;\n\t\t},\n\t\tsupportsArrayElement() {\n\t\t\t// A pg parameter needs to be available\n\t\t\tif (this.pgParameters.length === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// array_element must be supported\n\t\t\tlet process = this.processRegistry.get('array_element');\n\t\t\tif (!process) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t\t// ToDo: Check that labels are supported?!\n\t\t\t// return process.parameters.filter(p => p.name === 'label').length > 0;\n\t\t}\n\t},\n\tmethods: {\n\t\tshow(process = {}, pgParameters = []) {\n\t\t\tthis.$refs.modal.show(\"Insert Formula\");\n\t\t\tthis.result = {};\n\t\t\tthis.input = '';\n\t\t\tthis.replace = false;\n\t\t\tthis.pgParameters = pgParameters;\n\t\t\tthis.processGraph = Utils.isObject(process) && Utils.isObject(process.process_graph) ? process.process_graph : {};\n\n\t\t\ttry {\n\t\t\t\tthis.importFormula(process);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.info(error);\n\t\t\t}\n\n\t\t\tthis.arrayElements = {};\n\t\t\tif(!this.replace) {\n\t\t\t\t// If not replacing: Add all array_element calls for labels to the list so that we don't get duplicate array_element calls\n\t\t\t\tfor(let id in this.processGraph) {\n\t\t\t\t\tlet node = this.processGraph[id];\n\t\t\t\t\tif (node.process_id === 'array_element' && Utils.isObject(node.arguments) && node.arguments.label) {\n\t\t\t\t\t\tthis.arrayElements[node.arguments.label] = {from_node: node.id};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tonDrag(event, type, data) {\n\t\t\tswitch(type) {\n\t\t\t\tcase 'functions':\n\t\t\t\t\tlet params = (data.parameters || []).map(p => p.name);\n\t\t\t\t\tdata = data.id + '(' + params.join(', ') + ')';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'results':\n\t\t\t\t\tdata = '#' + data;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tevent.dataTransfer.setData(\"text/plain\", data);\n\t\t},\n\t\tallowDrop(event) {\n\t\t\tevent.preventDefault();\n\t\t},\n\t\tonDrop(event) {\n\t\t\tvar text = event.dataTransfer.getData(\"text/plain\");\n\t\t\tif (text) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tthis.$refs.editor.insert(text, false);\n\t\t\t}\n\t\t},\n\t\timportFormula(process) {\n\t\t\tif (!this.isMathProcess(process)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar pg = new ProcessGraph(process, this.processRegistry);\n\t\t\tpg.parse();\n\t\t\tlet formula = this.nodeToFormula(pg.getResultNode());\n\t\t\tif (formula) {\n\t\t\t\tthis.input = formula;\n\t\t\t\tthis.replace = true;\n\t\t\t}\n\t\t},\n\t\tnodeToFormula(node, parentOperator = null) {\n\t\t\tif (node.process_id === 'array_element') {\n\t\t\t\treturn '$' + (node.getArgument('label') || node.getArgument('index'));\n\t\t\t}\n\n\t\t\tlet operator = this.reverseOperatorMapping[node.process_id];\n\t\t\tlet process = this.processRegistry.get(node.process_id);\n\t\t\tlet isArrayData = (typeof this.arrayOperatorMapping[node.process_id] !== 'undefined');\n\n\t\t\tlet convertValue = value => {\n\t\t\t\tif (Utils.isObject(value)) {\n\t\t\t\t\tif (value.from_node) {\n\t\t\t\t\t\tlet refNode = node.getProcessGraph().getNode(value.from_node);\n\t\t\t\t\t\tif (refNode) {\n\t\t\t\t\t\t\tvalue = this.nodeToFormula(refNode, operator);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvalue = '#' + value.from_node;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (value.from_parameter) {\n\t\t\t\t\t\tvalue = value.from_parameter;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new Error('Objects not allowed');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t};\n\n\t\t\t// Create the list of arguments\n\t\t\tlet argList = [];\n\t\t\tlet params = Array.isArray(process.parameters) ? process.parameters : [];\n\t\t\tfor(let parameter of params) {\n\t\t\t\tlet value = convertValue(node.getRawArgument(parameter.name));\n\n\t\t\t\tif (isArrayData && Array.isArray(value) && parameter.name === 'data') {\n\t\t\t\t\targList = value.map(v => convertValue(v));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(typeof value !== 'undefined') {\n\t\t\t\t\targList.push(value);\n\t\t\t\t}\n\t\t\t\telse if(typeof parameter.default !== 'undefined') {\n\t\t\t\t\targList.push(parameter.default);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new Error('Argument for parameter \"' + parameter.name + '\" missing');\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\t // Filter null values for array data to handle ignore_nodata\n\t\t\tif (isArrayData) {\n\t\t\t\targList = argList.filter(v => v !== null);\n\t\t\t}\n\n\t\t\tif (operator) {\n\t\t\t\tlet strongOps = ['/', '*']; // \"Punktrechnung\" vor\n\t\t\t\tlet weakOps = ['-', '+']; // \"Strichrechung\"\n\t\t\t\tlet formula = argList\n\t\t\t\t\t.map(v => v < 0 ? '(' + v + ')' : v) // Put negative values in brackets\n\t\t\t\t\t.join(operator); // Merge everything together\n\t\t\t\t\n\t\t\t\t// Check whether brackets are required\n\t\t\t\tif (\n\t\t\t\t\t!parentOperator // No brackets on top-level\n\t\t\t\t\t|| (weakOps.includes(parentOperator) && weakOps.includes(operator)) // If operators are both weak, no brackets required\n\t\t\t\t\t|| (strongOps.includes(parentOperator) && strongOps.includes(operator)) // If operators are both strong, no brackets required\n\t\t\t\t\t|| operator === '^' // No brackets required for power, it's the strongest operation\n\t\t\t\t\t|| (weakOps.includes(parentOperator) && strongOps.includes(operator)) // If the parent operation is a weak operation (+/-) and this is a strong operation, no brackets required\n\t\t\t\t) {\n\t\t\t\t\treturn formula;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn '(' + formula + ')';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn node.process_id + '(' + argList.join(', ') + ')';\n\t\t\t}\n\t\t},\n\t\tcreateResult() {\n\t\t\tif (this.input.length === 0) {\n\t\t\t\tthis.$refs.modal.close();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tthis.result = {};\n\t\t\t\tlet formula = new Formula(this.input);\n\t\t\t\tlet res = this.parseTree(formula.tree);\n\t\t\t\tif (!Utils.isObject(res) || !res.from_node) {\n\t\t\t\t\tthrow new Error('Invalid formula specified.');\n\t\t\t\t}\n\t\t\t\t// Set result node\n\t\t\t\tthis.result[res.from_node].result = true;\n\t\t\t\t// Send result\n\t\t\t\tthis.$emit('save', this.result, this.replace);\n\t\t\t\tthis.$refs.modal.close();\n\t\t\t} catch(e) {\n\t\t\t\tUtils.exception(this, e);\n\t\t\t}\n\t\t},\n\t\tparseTree(tree) {\n\t\t\tlet key = Object.keys(tree)[0]; // There's never more than one property so no loop required\n\t\t\tswitch(key) {\n\t\t\t\tcase 'Number':\n\t\t\t\t\treturn Number.parseFloat(tree.Number);\n\t\t\t\tcase 'Identifier':\n\t\t\t\t\treturn this.getRef(tree.Identifier);\n\t\t\t\tcase 'Expression':\n\t\t\t\t\treturn this.parseTree(tree.Expression);\n\t\t\t\tcase 'FunctionCall':\n\t\t\t\t\tlet args = [];\n\t\t\t\t\tfor(let i in tree.FunctionCall.args) {\n\t\t\t\t\t\targs.push(this.parseTree(tree.FunctionCall.args[i]));\n\t\t\t\t\t}\n\t\t\t\t\treturn this.addProcess(tree.FunctionCall.name, args);\n\t\t\t\tcase 'Binary':\n\t\t\t\t\treturn this.addOperatorProcess(\n\t\t\t\t\t\ttree.Binary.operator,\n\t\t\t\t\t\tthis.parseTree(tree.Binary.left),\n\t\t\t\t\t\tthis.parseTree(tree.Binary.right)\n\t\t\t\t\t);\n\t\t\t\tcase 'Unary':\n\t\t\t\t\tlet val = this.parseTree(tree.Unary.expression);\n\t\t\t\t\tif (tree.Unary.operator === '-') {\n\t\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\t\treturn -val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn this.addOperatorProcess('*', -1, val);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn val;\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Operation ' + key + ' not supported.');\n\t\t\t}\n\t\t},\n\t\tgetRef(value) {\n\t\t\t// Convert native data types\n\t\t\tif (value === 'true') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (value === 'false') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (value === 'null') {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Output of a process\n\t\t\tif (typeof value === 'string' && value.startsWith('#')) {\n\t\t\t\tlet nodeId = value.substring(1);\n\t\t\t\tif (this.results.includes(nodeId)) {\n\t\t\t\t\treturn { from_node: nodeId };\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Array labels / indices\n\t\t\tif (this.supportsArrayElement && typeof value === 'string' && value.startsWith('$')) {\n\t\t\t\tlet ref = value.substring(1);\n\t\t\t\tif (!(ref in this.arrayElements)) {\n\t\t\t\t\t// ToDo: Check whether label is really supported - see implementation for supportsArrayElement()\n\t\t\t\t\tlet args = {\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tfrom_parameter: this.pgParameters[0].id\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tif (ref.match(/^\\d+$/)) {\n\t\t\t\t\t\targs.index = Number.parseInt(ref, 10);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\targs.label = ref;\n\t\t\t\t\t}\n\t\t\t\t\tthis.arrayElements[ref] = this.addProcess(\"array_element\", args);\n\t\t\t\t}\n\t\t\t\treturn this.arrayElements[ref];\n\t\t\t}\n\n\t\t\t// Everything else is a parameter\n\t\t\tif (this.pgParameters.filter(p => p.id === value).length === 0) {\n\t\t\t\t// ToDo: Add new parameter to process\n\t\t\t}\n\t\t\treturn { from_parameter: value };\n\t\t},\n\t\taddOperatorProcess(operator, left, right) {\n\t\t\tif (typeof this.operatorMapping[operator] !== 'undefined') {\n\t\t\t\tlet process = this.processRegistry.get(this.operatorMapping[operator]);\n\t\t\t\tlet args = {};\n\t\t\t\tif (!process || !Array.isArray(process.parameters) || process.parameters.length < 2) {\n\t\t\t\t\tthrow new Error(\"Process for operator \" + operator + \" must have at least two parameters\");\n\t\t\t\t}\n\t\t\t\targs[process.parameters[0].name || 'x'] = left;\n\t\t\t\targs[process.parameters[1].name || 'y'] = right;\n\t\t\t\treturn this.addProcess(process, args);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new Error('Operator ' + operator + ' not supported.');\n\t\t\t}\n\t\t},\n\t\taddProcess(process, args) {\n\t\t\tif (typeof process === 'string') {\n\t\t\t\tprocess = this.processRegistry.get(process);\n\t\t\t}\n\n\t\t\tif (!process) {\n\t\t\t\tthrow new Error(\"Process not available: \" + name);\n\t\t\t}\n\t\t\telse if (args.length > Utils.size(process.parameters)) {\n\t\t\t\tthrow new Error(\"Number of given arguments exceeds number of process parameters for process '\" + name + \"'.\");\n\t\t\t}\n\n\t\t\t// Convert arguments array to object\n\t\t\tif (Array.isArray(args)) {\n\t\t\t\tlet namedArgs = {};\n\t\t\t\tfor (let i in args) {\n\t\t\t\t\tlet parameter = process.parameters[i];\n\t\t\t\t\tnamedArgs[parameter.name] = args[i];\n\t\t\t\t}\n\t\t\t\targs = namedArgs;\n\t\t\t}\n\t\t\t// ToDo: Check all arguments against their schemas / check all required fields are given\n\n\t\t\t// Add node to result with unique id\n\t\t\tlet nodeId = Utils.getUniqueId();\n\t\t\tlet node = {\n\t\t\t\tprocess_id: process.id,\n\t\t\t\targuments: args\n\t\t\t};\n\t\t\tthis.result[nodeId] = node;\n\t\t\treturn { from_node: nodeId };\n\t\t}\n\t}\n}\n</script>\n\n<style scoped>\n.footer {\n\ttext-align: right;\n}\n.content {\n\tdisplay: flex;\n\tflex-direction: column;\n}\n.content .textEditor {\n\tflex-grow: 1;\n}\n.description {\n\tmargin-top: 1rem;\n\tdisplay: flex;\n\tflex-direction: column;\n\talign-items: flex-start;\n}\n.description p {\n\tmargin: 0.5em 0;\n}\n.editor {\n\twidth: 100%;\n\tmin-height: 4em;\n\theight: 10em;\n}\nkbd {\n\tfont-family: Consolas, \"Lucida Console\", monospace;\n\tdisplay: inline-block;\n\tborder-radius: 3px;\n\tpadding: 1px 5px;\n\tbox-shadow: 1px 1px 1px #777;\n\tmargin: 2px;\n\tfont-size: small;\n\tvertical-align: text-bottom;\n\tbackground: #eee;\n\tfont-weight: 600;\n\tcolor: #555;\n\tletter-spacing: 0.25px;\n}\nkbd.click {\n\tcursor: pointer;\n}\n</style>","import mod from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ExpressionModal.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ExpressionModal.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./ExpressionModal.vue?vue&type=template&id=396a9ae3&scoped=true&\"\nimport script from \"./ExpressionModal.vue?vue&type=script&lang=js&\"\nexport * from \"./ExpressionModal.vue?vue&type=script&lang=js&\"\nimport style0 from \"./ExpressionModal.vue?vue&type=style&index=0&id=396a9ae3&scoped=true&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"396a9ae3\",\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}